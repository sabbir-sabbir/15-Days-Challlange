// JavaScript Fundamentals
answer 1-
JavaScript has 8 basic data types:

1.Number: Represents both integers and floating-point numbers (e.g., 42, 3.14).
2.BigInt: For large integers beyond the Number limit (e.g., 123n).
3.String: Text data inside quotes (e.g., "hello", 'world').
4.Boolean: Logical values, either true or false.
5.Undefined: A variable with no assigned value.
6.Null: Represents "no value" or "empty".
7.Symbol: Unique identifiers (used in advanced scenarios).
8.Object: Collections of data or functions (e.g., {name: "John", age: 30}).
These data types help organize and manage different kinds of information in JavaScript.


answer 2-
In JavaScript, var, let, and const are used to declare variables, but they have some differences:

var:

Function-scoped (limited to the function where it's declared).
Can be redeclared and updated.
Allows hoisting (can be used before declaration, but value will be undefined).

let:

Block-scoped (limited to the block {} where it's declared).
Can be updated, but not redeclared in the same scope.
No hoisting in the same way as var.

const:

Block-scoped like let.
Cannot be updated or redeclared; must be assigned a value when declared.
Used for values that shouldn't change (constants).
In general, use let for variables that may change, const for constants, and avoid var for better code clarity and fewer bugs.


answer 3-
In JavaScript, == and === are comparison operators with key differences:

== (loose equality):

Compares values only, not types.
Performs type conversion if types differ (e.g., 5 == "5" is true).
=== (strict equality):

Compares both values and types.
No type conversion; both must be the same type and value (e.g., 5 === "5" is false).


answer 4-
Type coercion in JavaScript is the automatic conversion of one data type to another when values of different types are used together.

console.log("5" + 2); // "52" (number 2 is coerced to a string)
console.log("5" - 2); // 3 (string "5" is coerced to a number)

In the first case, + converts 2 to "2" and concatenates it, while - converts "5" to 5 for subtraction.



answer 5-
In JavaScript, scope determines where variables and functions can be accessed or used.

There are three main types of scope:

Global Scope:

Variables declared outside any function or block.
Accessible from anywhere in the code.
Function Scope:

Variables declared inside a function with var.
Accessible only within that function.
Block Scope:

Variables declared with let or const inside { } (e.g., loops, conditionals).
Accessible only within that specific block.

let x = 10; // Global scope

function myFunction() {
  var y = 20; // Function scope
  if (true) {
    let z = 30; // Block scope
  }
  console.log(z); // Error: z is not defined
}



answer 6-
Hoisting in JavaScript is a behavior where variable and function declarations are moved to the top of their scope (before execution), making them accessible before they're actually written in the code.

example-
Function Hoisting:
Entire functions are hoisted, so they can be called before their declaration
greet(); // Works
function greet() {
  console.log("Hello");
}




answer 7-
Template literals are strings enclosed by backticks `, allowing for easier string interpolation and multi-line strings in JavaScript.
String Interpolation:

Insert variables and expressions directly into strings using ${ }.
const name = "John";
console.log(`Hello, ${name}!`); // "Hello, John!"



answer 8-
A higher-order function in JavaScript is a function that does one or both of the following:

Takes other functions as arguments.
Returns a function as its result
Higher-order functions help with reusable, flexible, and modular code.

ex-
function greet(name) {
  return `Hello, ${name}`;
}

function callWithGreeting(greetingFunc, name) { // Higher-order function
  return greetingFunc(name);
}

console.log(callWithGreeting(greet, "Alice")); // "Hello, Alice"



answer 9-
Arrow functions are a more concise way to write functions in JavaScript. They use the => syntax and have some key differences compared to regular functions:

1.Syntax:
Arrow functions are shorter and do not require the function keyword.
const add = (a, b) => a + b; // Arrow function

2.Lexical this:

Arrow functions do not have their own this context; they inherit this from the surrounding scope.
function Person() {
  this.age = 0;

  setInterval(() => {
    this.age++; // 'this' refers to the Person instance
    console.log(this.age);
  }, 1000);
}

new Person(); // Increments age every second

3.No arguments Object:

Arrow functions do not have their own arguments object. Use rest parameters instead.
const sum = (...args) => args.reduce((a, b) => a + b, 0);



answer 10-
An Immediately Invoked Function Expression (IIFE) is a function that is defined and executed immediately after its creation. It helps to create a private scope and avoid polluting the global namespace.

Syntax:
An IIFE is typically defined using parentheses around the function and then followed by another set of parentheses to invoke it:
(function() {
  console.log("I am an IIFE!");
})();

Key Points:
Private Scope: Variables declared inside an IIFE cannot be accessed from outside, preventing global namespace pollution.
Immediate Execution: The function runs right away after it's defined.

let result = (function(x, y) {
  return x + y;
})(5, 10); // Immediately invoked with arguments 5 and 10

console.log(result); // Outputs: 15


Functions and Objects...................................
answer 1-
Closures in JavaScript are a powerful feature that allows a function to remember its surrounding state (the scope) even after it has finished executing. A closure is created when a function is defined inside another function, and the inner function retains access to the outer function's variables.

Function and Scope: When a function is created, it has access to its own scope, the outer function's scope, and the global scope.

Persistent State: Closures can maintain a reference to the outer function's variables, even after the outer function has completed execution.

Use Cases: Closures are often used for data encapsulation, maintaining private variables, and creating factory functions.

example-
function createCounter() {
  let count = 0; // Private variable

  return {
    increment: function() {
      count++;
      console.log(count);
    },
    decrement: function() {
      count--;
      console.log(count);
    },
    getCount: function() {
      return count;
    }
  };
}

const counter = createCounter();
counter.increment(); // Output: 1
counter.increment(); // Output: 2
counter.decrement(); // Output: 1
console.log(counter.getCount()); // Output: 1

Explanation:-
Outer Function: The createCounter function contains a private variable count.

Inner Functions: It returns an object with methods (increment, decrement, getCount) that are closures. These methods have access to count, even after createCounter has finished executing.

Persistent State: Each time you call increment or decrement, the state of count is maintained across calls, demonstrating how closures can keep track of and manipulate private variables.


answer 2-
The this keyword in JavaScript refers to the current execution context of a function or object. Its value changes depending on where and how a function is called.

1. Global Context:
In the global scope (outside of any function), this refers to the global object (window in browsers).
example-
console.log(this); // window (in a browser)
The value of this depends on the context:

Global scope: global object (window).
Object methods: the object itself.
Constructor functions: the new instance.
Arrow functions: inherited from the surrounding scope.
Event handlers: the DOM element triggering the even


answer 3-
In JavaScript, you can create an object in several ways:
1. Object Literal:
The most common and simplest way to create an object.
const person = {
  name: "Alice",
  age: 25,
  greet: function() {
    console.log("Hello!");
  }
};


2. new Object():
Uses the Object constructor.
const person = new Object();
person.name = "Alice";
person.age = 25;


3. Constructor Function:
Define a function that initializes properties, then use new to create an object.
function Person(name, age) {
  this.name = name;
  this.age = age;
}
const person = new Person("Alice", 25);


4. Object.create():
Creates a new object with the specified prototype.
const personPrototype = {
  greet: function() {
    console.log("Hello!");
  }
};
const person = Object.create(personPrototype);
person.name = "Alice";
person.age = 25;


5. Class Syntax (ES6+):
Use the class keyword for a more structured approach.
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }
}
const person = new Person("Alice", 25);


answer 4----
In JavaScript, null and undefined represent different absence values:

undefined:
A variable is undefined when it has been declared but not assigned a value.
It's also the default return value of functions with no explicit return.
let a;
console.log(a); // undefined

null:
null is an intentional assignment that indicates an empty or unknown value.
It must be set explicitly.
let b = null;
console.log(b); // null



answer 5----
In JavaScript, copying an object can be done in two main ways: shallow copy and deep copy.

1. Shallow Copy:
A shallow copy creates a new object but only copies references for nested objects, not the actual nested objects themselves.
Common methods: Object.assign() or the spread syntax { ...obj }.

const original = { name: "Alice", address: { city: "Wonderland" } };
const shallowCopy = { ...original };

shallowCopy.name = "Bob"; // Only changes shallowCopy
shallowCopy.address.city = "New City"; // Changes both original and shallowCopy (reference)

console.log(original); // { name: "Alice", address: { city: "New City" } }

2. Deep Copy:
A deep copy creates a new object and copies all nested objects as well, so they’re fully independent.
Common method: JSON.parse(JSON.stringify(obj)) (note this doesn’t work with functions or special values like undefined).

const original = { name: "Alice", address: { city: "Wonderland" } };
const deepCopy = JSON.parse(JSON.stringify(original));

deepCopy.address.city = "New City"; // Only changes deepCopy

console.log(original); // { name: "Alice", address: { city: "Wonderland" } }



answer 6-
In JavaScript, call, apply, and bind are methods used to control the value of this in a function and allow for flexible function invocation.
1. call:
Invokes a function immediately and lets you specify this and pass arguments individually.
function greet(greeting) {
  console.log(`${greeting}, ${this.name}`);
}
const person = { name: "Alice" };
greet.call(person, "Hello"); // "Hello, Alice"

2. apply:
Similar to call, but accepts arguments as an array instead of individually.
greet.apply(person, ["Hi"]); // "Hi, Alice"

3. bind:
Creates a new function with this permanently set to the specified value; does not invoke the function immediately.
const greetPerson = greet.bind(person, "Hey");
greetPerson(); // "Hey, Alice"



answer 7-
In JavaScript, the prototype chain is a mechanism for inheritance, where objects can inherit properties and methods from other objects.

Prototype Chain:
Every JavaScript object has a prototype, which is a reference to another object.
When you try to access a property or method on an object, JavaScript first looks at the object itself. If it doesn't find it, it looks up the prototype chain until it finds the property or reaches null.

Inheritance:
JavaScript uses prototypes to implement inheritance. Objects can inherit properties and methods from their prototype objects, creating a chain of inheritance.
This allows objects to share functionality without duplicating code.
function Person(name) {
  this.name = name;
}

Person.prototype.greet = function() {
  console.log(`Hello, I'm ${this.name}`);
};

const alice = new Person("Alice");
alice.greet(); // "Hello, I'm Alice"

// `alice` inherits the `greet` method from `Person.prototype`.





Arrays and Strings-----------------------------------------------
answer 1-
Here’s a list of common array methods in JavaScript:

push() - Adds elements to the end of an array.
pop() - Removes the last element from an array.
shift() - Removes the first element from an array.
unshift() - Adds elements to the beginning of an array.
map() - Creates a new array by applying a function to each element.
filter() - Creates a new array with elements that meet a condition.
reduce() - Reduces the array to a single value using a function.
forEach() - Executes a function on each array element.
find() - Returns the first element that meets a condition.
findIndex() - Returns the index of the first element that meets a condition.
includes() - Checks if an array contains a specified element.
concat() - Merges two or more arrays.
slice() - Returns a portion of an array as a new array.
splice() - Adds, removes, or replaces elements in an array.
sort() - Sorts elements in place.
reverse() - Reverses the order of elements in place.
join() - Joins all elements of an array into a string.
every() - Checks if all elements meet a condition.
some() - Checks if any element meets a condition.
indexOf() - Returns the first index of a specified element.
lastIndexOf() - Returns the last index of a specified element.
flat() - Flattens nested arrays into a single-level array.
flatMap() - Maps and flattens array elements.
fill() - Fills elements in an array with a static value.


answer 2-
 The difference between map() and forEach() in arrays:

map(): Creates a new array by applying a function to each element. Returns the modified array.

javascript--
const newArr = arr.map(x => x * 2); // Returns a new array

forEach(): Executes a function on each element, but does not return a new array. Only useful for performing actions, not transformations.
arr.forEach(x => console.log(x)); // No new array is created

Summary:
map() returns a new array with transformed values.
forEach() does not return anything; it’s used for performing actions on each element.


answer 3----
The filter() method in JavaScript creates a new array with all elements that pass a specified condition.

How it Works:
It takes a callback function that tests each element of the array.
If an element satisfies the condition (returns true), it’s added to the new array.
The original array remains unchanged.
Example:

const numbers = [1, 2, 3, 4];
const evens = numbers.filter(num => num % 2 === 0); // [2, 4]



answer 4---
The reduce() method in JavaScript reduces an array to a single value by applying a function to each element.

How it Works:
It takes a callback function and an initial value.
The callback function runs on each element, accumulating a result in each step.
The accumulated result is returned as a single final value.

const numbers = [1, 2, 3, 4];
const sum = numbers.reduce((accumulator, num) => accumulator + num, 0); // 10



answer 5---
To find the length of a string and reverse it in JavaScript:

1. Find Length:
Use the length property.
const str = "hello";
const length = str.length; // 5

2. Reverse String:
Convert to array, reverse, and join back into a string.
const reversed = str.split('').reverse().join(''); // "olleh"



answer 6---
Template literals in JavaScript are strings enclosed by backticks (`) instead of quotes. They allow for easier string manipulation with features like multi-line strings and variable interpolation.
1.Variable Interpolation: Insert variables directly within ${}.
const name = "Alice";
const greeting = `Hello, ${name}!`; // "Hello, Alice!"


2.Multi-line Strings: Write strings across multiple lines.
const message = `This is
a multi-line string.`;


3.Expression Evaluation: Use expressions inside ${}.
const total = `Total: ${5 + 3}`; // "Total: 8"



answer 7---
To remove duplicates from an array in JavaScript, use the Set object or filter() method.

Using Set:
A Set only stores unique values
const arr = [1, 2, 2, 3];
const uniqueArr = [...new Set(arr)]; // [1, 2, 3]


Using filter():
Check if the element’s index matches the first occurrence in the array
const arr = [1, 2, 2, 3];
const uniqueArr = arr.filter((item, index) => arr.indexOf(item) === index); // [1, 2, 3]



Control Structures and Error Handling---------------------------------------
answer 1--
JavaScript uses implicit type conversion (also called type coercion) to automatically convert data types when needed.

How It Works:
JavaScript converts values to the expected type in expressions, such as when combining strings and numbers or comparing different types.
This can lead to unexpected results because JavaScript tries to “guess” the type conversion.

Examples:
1.String and Number Concatenation:
const result = "5" + 3; // "53" (number 3 is converted to a string)

2.Comparisons:
const isEqual = "5" == 5; // true (string "5" is converted to number 5)



answer 2---
The typeof operator in JavaScript returns a string indicating the type of a value.

Common Results:
typeof "hello" → "string"
typeof 42 → "number"
typeof true → "boolean"
typeof undefined → "undefined"
typeof null → "object" (a quirk in JavaScript)
typeof {} → "object"
typeof [] → "object" (arrays are technically objects)
typeof function() {} → "function"
Summary:
typeof helps identify data types, but note that null and arrays return "object".


answer 3---
NaN (Not-a-Number) in JavaScript is a special value that represents a computation error when a non-numeric value is involved in a mathematical operation. It's still a number type, but it signifies an invalid number.

Checking for NaN:
1.isNaN(): Checks if a value is NaN or can become NaN.
isNaN("hello"); // true
isNaN(123); // false



Miscellaneous----------------------------------------------------------
answer 1---
Event delegation is a technique in JavaScript that allows you to manage events more efficiently by taking advantage of the event bubbling mechanism.
How It Works:
Instead of attaching event listeners to multiple individual elements, you attach a single event listener to a parent element.
When an event occurs on a child element, it bubbles up to the parent, where the listener is executed.
This allows you to handle events for dynamic elements that may not exist when the listener is first added.

<ul id="itemList">
  <li>Item 1</li>
  <li>Item 2</li>
  <li>Item 3</li>
</ul>

<script>
  const list = document.getElementById('itemList');
  list.addEventListener('click', function(event) {
    if (event.target.tagName === 'LI') {
      console.log('Clicked on:', event.target.textContent);
    }
  });
</script>



answer 2---
Default parameters in JavaScript allow you to set default values for function parameters. If no argument is provided or if undefined is passed, the default value is used.

How It Works:
You can specify default values in the function definition by assigning them directly to parameters.

Example:--
function greet(name = "Guest") {
  return `Hello, ${name}!`;
}

console.log(greet()); // "Hello, Guest!"
console.log(greet("Alice")); // "Hello, Alice!"



answer 3---
The difference between synchronous and asynchronous programming lies in how tasks are executed and how they handle operations that may take time, such as I/O operations.

Synchronous Programming:
Execution Flow: Tasks are executed one after the other, in a sequential manner.
Blocking: Each task must complete before the next one starts, which can lead to delays if a task takes a long time.

code- 
console.log("Task 1"); // Executes first
console.log("Task 2"); // Executes after Task 1

Asynchronous Programming:
Execution Flow: Tasks can start and run independently of one another, allowing other code to execute while waiting for tasks to complete.
Non-blocking: It doesn't stop the execution of other tasks; you can handle results using callbacks, promises, or async/await.

code--
console.log("Task 1"); // Executes first
setTimeout(() => console.log("Task 2"), 1000); // Executes after 1 second
console.log("Task 3"); // Executes immediately after Task 1



answer 4---
The setTimeout function in JavaScript is used to delay the execution of a function for a specified amount of time. It takes two main arguments:

A function (or code) to run.
A delay time in milliseconds (1 second = 1000 milliseconds).
After the specified time, setTimeout will run the function once. It's commonly used to create delays, handle timed actions, or defer certain operations.
setTimeout(() => {
  console.log("Hello after 2 seconds");
}, 2000); // 2000 ms = 2 seconds



answer 5---
JSON.stringify() and JSON.parse() are methods in JavaScript used to work with JSON (JavaScript Object Notation) data:

JSON.stringify(): Converts a JavaScript object or array into a JSON string. This is useful for sending data to a server or saving it in a format that's easy to store.
const obj = { name: "Alice", age: 25 };
const jsonString = JSON.stringify(obj); // '{"name":"Alice","age":25}'


JSON.parse(): Converts a JSON string back into a JavaScript object. This is useful for reading data that was stored as JSON or received from a server.
const jsonString = '{"name":"Alice","age":25}';
const obj = JSON.parse(jsonString); // { name: "Alice", age: 25 }



answer 6---
In JavaScript, you can handle asynchronous code with three main approaches:

Callbacks: A function is passed as an argument to another function, which is then executed after an asynchronous operation completes. However, callbacks can lead to "callback hell" if nested too deeply.
function fetchData(callback) {
  setTimeout(() => {
    callback("Data loaded");
  }, 1000);
}

fetchData((result) => {
  console.log(result);
});


Promises: A Promise represents a value that may be available now, or in the future. It uses .then() and .catch() methods for handling the result or error.
fetchData()
  .then((result) => console.log(result))
  .catch((error) => console.error(error));


Async/Await: Built on Promises, it lets you write asynchronous code that looks synchronous. You use await to pause code execution until the Promise is resolved.
async function fetchDataAsync() {
  const result = await fetchData();
  console.log(result);
}

fetchDataAsync();




answer 7---
The Event Loop in JavaScript is a mechanism that handles asynchronous operations and ensures non-blocking execution. It allows JavaScript to perform tasks like handling user input, making API calls, or waiting for timers, without stopping the main thread.

Here's how it works in a nutshell:

Call Stack: Holds all the functions currently being executed. Synchronous code runs here directly, one line at a time.

Web APIs: Asynchronous tasks like setTimeout, HTTP requests, or event listeners are offloaded here.

Callback Queue: When an asynchronous task completes, its callback function goes to the queue, waiting to be executed.

Event Loop: Constantly checks if the Call Stack is empty. If it is, it moves the first task from the Callback Queue to the Call Stack to execute.

In short, the Event Loop enables JavaScript to manage asynchronous code by coordinating tasks between the Call Stack and the Callback Queue, allowing smooth, non-blocking behavior.




Advance JS Interview Question.................................................
ES6 (10 questions)---


answer 1-------
Arrow functions, introduced in ES6, are a shorter syntax for writing functions in JavaScript. They use the => (arrow) symbol and have some key differences from regular functions:
Regular function:
function greet(name) {
  return `Hello, ${name}`;
}


Arrow function:
const greet = (name) => `Hello, ${name}`;

Differences
this Binding: Arrow functions do not have their own this context. They inherit this from the enclosing scope, making them ideal for callbacks and methods where this binding is needed.

Conciseness: Arrow functions provide a shorter, more readable syntax, especially for small or inline functions.

No arguments Object: Arrow functions do not have their own arguments object, so you'd use rest parameters (...args) if needed.


answer 2---
Destructuring assignment in ES6 is a syntax that allows you to unpack values from arrays or properties from objects directly into distinct variables, making your code cleaner and more readable.
With Arrays
You can extract values from arrays and assign them to variables based on their positions.
const numbers = [1, 2, 3];
const [a, b, c] = numbers; // a = 1, b = 2, c = 3


project---
function logProperties(obj) {
  for (const key in obj) {
    if (obj.hasOwnProperty(key)) {
      console.log(`${key}: ${obj[key]}`);
    }
  }
}

Explanation
This function uses a for...in loop to iterate over each property in the object.
It checks obj.hasOwnProperty(key) to ensure it only logs properties that belong directly to obj (not inherited properties).
It logs each key-value pair in the format key: value.



answer 3----
var
Scope: Function-scoped, meaning it’s available within the function where it's declared or globally if declared outside any function.
Hoisting: Variables declared with var are hoisted (moved to the top of their scope) and initialized as undefined.
Reassignment: Can be reassigned and redeclared within the same scope.

let
Scope: Block-scoped, meaning it's only available within the { } block in which it's declared.
Hoisting: let variables are hoisted but not initialized, so they can’t be used before they’re declared.
Reassignment: Can be reassigned but cannot be redeclared within the same scope.


const
Scope: Block-scoped, like let.
Hoisting: const is hoisted but uninitialized, so it can’t be used before declaration.
Reassignment: Cannot be reassigned, meaning the variable’s reference cannot change. However, for objects and arrays, their contents can still be modified.



answer 4---
The spread operator (...) in JavaScript allows you to "spread" elements of an array or properties of an object into another array or object. It’s useful for copying, combining, and expanding data structures.

Copying an array:
const arr1 = [1, 2, 3];
const arr2 = [...arr1]; // [1, 2, 3]


Combining arrays:
const arr1 = [1, 2];
const arr2 = [3, 4];
const combined = [...arr1, ...arr2]; // [1, 2, 3, 4]


Expanding elements:
const numbers = [1, 2, 3];
console.log(...numbers); // Logs: 1 2 3


Copying an object:
const obj1 = { name: "Alice" };
const obj2 = { ...obj1 }; // { name: "Alice" }


Merging objects:
const obj1 = { name: "Alice" };
const obj2 = { age: 25 };
const combined = { ...obj1, ...obj2 }; // { name: "Alice", age: 25 }




answer 5---

Template literals, introduced in ES6, make string interpolation easier and more readable by allowing you to embed variables and expressions directly within strings. They use backticks ` instead of quotes.

1.String Interpolation: Use ${} to embed variables or expressions directly in a string.
const name = "Alice";
const greeting = `Hello, ${name}!`; // "Hello, Alice!"

2.Multi-line Strings: Template literals can span multiple lines without needing escape characters.

let x = "Sabbir";
console.log(`${x}

This is my name`)




answer 6---
In ES6 (JavaScript), default parameters allow you to set default values for function parameters. If a parameter is not provided (or is undefined), the default value is used instead. This makes functions more flexible and reduces the need for additional code to handle missing arguments.
function greet(name = 'Guest') {
  console.log(`Hello, ${name}!`);
}

greet();         // Output: Hello, Guest!
greet('Alice');  // Output: Hello, Alice!




answer 7---
In ES6, Map and Set are new data structures that offer unique ways to store and manage data, different from traditional objects and arrays.

Map:
A Map is a collection of key-value pairs.
Unlike objects, keys in a Map can be any type (e.g., objects, functions, or primitive data types).
Maintains the order of entries, which means it remembers the insertion order.
let map = new Map();
map.set('name', 'Alice');
map.set(42, 'The Answer');
console.log(map.get('name'));  // Output: Alice


Set:
A Set is a collection of unique values (no duplicates).
Can hold any type of value (like primitives or objects).
Automatically removes duplicates, which is helpful for storing unique items.
let set = new Set([1, 2, 3, 3]);
console.log(set);  // Output: Set { 1, 2, 3 }

Differences:
Map is for key-value pairs, similar to objects but with more flexibility in key types.
Set is for storing unique values, unlike arrays which allow duplicates.

project---
// Create a new Map to act as a dictionary
let dictionary = new Map();

// Function to add a word and its definition
function addWord(word, definition) {
  dictionary.set(word, definition);
  console.log(`Added: ${word}`);
}

// Function to get the definition of a word
function getDefinition(word) {
  if (dictionary.has(word)) {
    return dictionary.get(word);
  } else {
    return `Definition not found for "${word}".`;
  }
}

// Function to delete a word
function deleteWord(word) {
  if (dictionary.delete(word)) {
    console.log(`Deleted: ${word}`);
  } else {
    console.log(`"${word}" not found in the dictionary.`);
  }
}

// Function to list all words in the dictionary
function listWords() {
  console.log("Dictionary contents:");
  for (let [word, definition] of dictionary) {
    console.log(`${word}: ${definition}`);
  }
}

// Example usage
addWord("JavaScript", "A high-level programming language used for web development.");
addWord("Map", "A collection of key-value pairs in JavaScript.");

console.log(getDefinition("JavaScript")); // Output: JavaScript definition
deleteWord("Map");
listWords();





answer 8---
The for...of loop in JavaScript is used to iterate over iterable objects like arrays, strings, Maps, Sets, etc., by accessing values directly.
let array = ['a', 'b', 'c'];
for (let value of array) {
  console.log(value);  // Output: a, b, c
}

Key Differences:
for...of: Loops through values of an iterable (like array items or characters in a string).
for...in: Loops through keys or property names of an object.

let object = {a: 1, b: 2, c: 3};
for (let key in object) {
  console.log(key);  // Output: a, b, c
}




answer 9---
In JavaScript, a Promise is an object that represents the eventual completion (or failure) of an asynchronous operation and its resulting value.

Promise States:
Pending – Initial state, the operation hasn’t completed yet.
Fulfilled – The operation completed successfully.
Rejected – The operation failed.
Using .then() and .catch():
.then() is used to handle a fulfilled Promise and execute code when it succeeds.
.catch() is used to handle a rejected Promise and manage errors.


let promise = new Promise((resolve, reject) => {
  let success = true;
  if (success) {
    resolve("Operation successful!");
  } else {
    reject("Operation failed.");
  }
});

promise
  .then((result) => {
    console.log(result);  // Output: Operation successful!
  })
  .catch((error) => {
    console.log(error);   // If rejected, Output: Operation failed.
  });


project--
// Create a promise that resolves after 2 seconds
let myPromise = new Promise((resolve) => {
  setTimeout(() => {
    resolve("Promise resolved after 2 seconds!");
  }, 2000);
});

// Use .then() to log the message when the promise resolves
myPromise.then((message) => {
  console.log(message);  // Output: Promise resolved after 2 seconds!
});





answer 10---
async/await is a syntax in JavaScript that simplifies working with Promises, making asynchronous code look and behave more like synchronous code.

How it Works:
async: When you declare a function with async, it automatically returns a Promise.
await: Inside an async function, await pauses execution until a Promise is resolved. This allows you to write asynchronous code in a sequential, readable way.
async function fetchData() {
  try {
    let response = await fetch('https://api.example.com/data');  // Waits for the fetch Promise
    let data = await response.json();                           // Waits for the JSON conversion
    console.log(data);
  } catch (error) {
    console.log('Error:', error);
  }
}

fetchData();




DOM (8 questions)..................................
answer 1---
||
The DOM (Document Object Model) is a structured representation of an HTML document. It represents the page’s elements as a tree of nodes that JavaScript can access and manipulate.

How JavaScript Interacts with the DOM:
JavaScript can use the DOM API to:

Select elements (e.g., document.getElementById()).
Modify content (e.g., element.textContent = "Hello!").
Change styles (e.g., element.style.color = "blue").
Add/remove elements (e.g., document.createElement() and parentNode.appendChild()).

let heading = document.getElementById("myHeading"); // Select element
heading.textContent = "New Heading";                // Modify content
heading.style.color = "red";                        // Change style




answer 2---
1. getElementById()
Selects an element by its ID.
Returns a single element or null if not found.

let element = document.getElementById("myElement");


2. querySelector()
Selects the first element that matches a CSS selector (like .class, #id, tag).
Returns a single element or null if not found.

let element = document.querySelector(".myClass");  // First element with class 'myClass'


3. querySelectorAll()
Selects all elements that match a CSS selector.
Returns a NodeList (a list of elements), which you can loop through.

let elements = document.querySelectorAll("p");     // All <p> elements
elements.forEach((el) => console.log(el.textContent));


project-
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Change Color</title>
  <style>
    #colorBox {
      width: 200px;
      height: 200px;
      background-color: lightblue;
    }
  </style>
</head>
<body>

  <div id="colorBox"></div>
  <button id="changeColorButton">Change Color</button>

  <script src="script.js"></script>
</body>
</html>


// Select the div and button elements
let colorBox = document.getElementById("colorBox");
let button = document.getElementById("changeColorButton");

// Function to change the color of the div
button.addEventListener("click", () => {
  colorBox.style.backgroundColor = "lightgreen"; // Change to a new color
});



answer 3----
In JavaScript, event listeners are used to respond to events (like clicks, key presses, etc.) on elements.

addEventListener():
addEventListener() attaches an event listener to an element and specifies the function to run when the event occurs.
It allows you to listen for different types of events (e.g., click, keydown, mouseover) and execute a function in response.

let button = document.getElementById("myButton");

// Add a click event listener to the button
button.addEventListener("click", () => {
  alert("Button clicked!");
});




answer 4---
Event delegation is a technique in JavaScript where you attach a single event listener to a parent element instead of multiple listeners to individual child elements. The parent listens for events on its children and uses the event's propagation to handle events on specific elements.

Why It's Useful:
Efficiency: Instead of adding event listeners to many child elements, you only add one to the parent.
Dynamic Content: It works even for dynamically added elements (elements added after the page loads).

// Parent container with many list items
let parent = document.getElementById("parent");

parent.addEventListener("click", (event) => {
  // Check if the clicked element is a list item
  if (event.target && event.target.tagName === "LI") {
    console.log(`List item clicked: ${event.target.textContent}`);
  }
});




answer 5---
1. innerHTML:
Gets or sets the HTML content inside an element (including tags).
Can return HTML as a string (with elements like <p>, <strong>, etc.).
Allows for HTML manipulation.

let div = document.getElementById("myDiv");
console.log(div.innerHTML);  // <p>Hello <strong>world</strong></p>

2. textContent:
Gets or sets the plain text inside an element (without any HTML tags).
Returns all text, including hidden text (e.g., in <script> tags).

let div = document.getElementById("myDiv");
console.log(div.textContent);  // Hello world

3. innerText:
Similar to textContent, but it returns rendered text, meaning it respects styles like display: none (hides text).
Can be slower than textContent because it also takes layout and visibility into account.

let div = document.getElementById("myDiv");
console.log(div.innerText);  // Hello world (visible text only)



answer 6---
let div = document.getElementById("myDiv");

// Change background color
div.style.backgroundColor = "blue";

// Change font size
div.style.fontSize = "20px";

// Change width and height
div.style.width = "200px";
div.style.height = "100px";



answer 7---
In JavaScript, you can traverse the DOM (Document Object Model) by moving between elements using properties like parentNode, firstChild, lastChild, etc. These properties help you access an element's neighbors or ancestors.

let div = document.getElementById("myDiv");
console.log(div.firstChild);   // First child of div
console.log(div.lastChild);    // Last child of div
console.log(div.parentNode);   // Parent element of div
console.log(div.nextSibling);  // Next sibling element of div

Summary:
parentNode: Get the parent of an element.
firstChild: Get the first child (can be text or element).
lastChild: Get the last child (can be text or element).
nextSibling: Get the next sibling element or text node.
previousSibling: Get the previous sibling element or text node. 



answer 8---
In JavaScript event handling, preventDefault() and stopPropagation() are methods used to control the behavior of events.
1. preventDefault():
Purpose: It prevents the default action associated with the event from occurring.
Example: For a form submission, calling preventDefault() prevents the form from being submitted when the button is clicked.

document.getElementById("myButton").addEventListener("click", function(event) {
  event.preventDefault();  // Prevents the default action (e.g., form submission)
  console.log("Button clicked, but form won't submit.");
});


2. stopPropagation():
Purpose: It stops the event from bubbling up or propagating to parent elements.
Example: If you have a click event on a button inside a div, calling stopPropagation() on the button will prevent the click event from reaching the div.

document.getElementById("myButton").addEventListener("click", function(event) {
  event.stopPropagation();  // Stops the click event from reaching parent elements
  console.log("Button clicked, but event won't propagate to parent.");
});

document.getElementById("myDiv").addEventListener("click", function() {
  console.log("Div clicked.");
});




BOM (8 questions)
answer 1---
The Browser Object Model (BOM) in JavaScript refers to the collection of objects that allow JavaScript to interact with the browser outside of the HTML content. It provides access to browser features such as the window, history, and navigation.

Key Objects in BOM:
1.window:
The global object that represents the browser window.
Used to access properties like the alert(), location, setTimeout(), etc.
window.alert("Hello!");  // Displays an alert box


location:
Provides information about the URL of the current page and allows you to change it.
console.log(location.href);  // Logs the current URL
location.href = "https://www.example.com";  // Redirects to a new URL

navigator:
Provides information about the browser itself (like its name, version, and platform).
console.log(navigator.userAgent);  // Logs browser's user agent string



answer 2---
In JavaScript, window and document are both part of the Browser Object Model (BOM), but they serve different purposes:

1. window:
Represents the browser window or tab.
It is the global object in JavaScript (the this keyword refers to the window object).
It gives access to browser-related properties and methods like alert(), setTimeout(), and location.


2. document:
Represents the HTML content loaded in the browser window (the DOM).
Used to interact with the structure and elements of the webpage, like getting or modifying elements with methods like getElementById().



answer 3----
Key Differences:
Persistence:
localStorage: Persists until manually deleted.
sessionStorage: Persists only during the session.
Cookies: Can be set to expire or persist based on the expiration date.
Capacity:
localStorage and sessionStorage: More space (5-10 MB).
Cookies: Smaller space (4 KB).
Scope:
localStorage: Available across all tabs and windows.
sessionStorage: Available only in the current tab.
Cookies: Sent to the server with each request and can have an expiration date.

localStorage:
localStorage.setItem("username", "John");
let username = localStorage.getItem("username");  // "John"

sessionStorage:
sessionStorage.setItem("sessionId", "12345");
let sessionId = sessionStorage.getItem("sessionId");  // "12345"

3. Cookies:
document.cookie = "username=John; expires=Thu, 31 Dec 2025 12:00:00 UTC";



answer 4---
The navigator object in JavaScript provides information about the browser and the system it's running on. It's part of the Browser Object Model (BOM) and allows you to access details like the browser's version, platform, language, and more.

navigator.userAgent:

Provides a string containing details about the browser (name, version, and OS).
Example: "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"
navigator.language:

Returns the preferred language of the user (e.g., "en-US" for English).
Example: "en-US"
navigator.platform:

Returns the platform (OS) of the device (e.g., "Win32", "Linux", "MacIntel").
navigator.online:

A Boolean value indicating whether the browser is online or offline.
Example: navigator.onLine will be true if online, false if offline.
navigator.cookieEnabled:

Returns true if cookies are enabled in the browser, false otherwise.
Example: navigator.cookieEnabled
navigator.geolocation:

Provides access to the device's geographic location (if allowed by the user).
Example: You can use it to get the user's latitude and longitude.




answer 5---
In JavaScript, the window.open and window.close methods are used to control browser windows.

1. window.open():
Purpose: Opens a new browser window or tab with a specified URL.

Syntax: window.open(url, name, specs, replace)

url: The URL to open (can be an empty string to open a blank window).
name: The name of the window (e.g., "myWindow"). If the window already exists with this name, it will be reused.
specs: Optional settings like size and features (e.g., "width=500,height=500").
replace: Optional boolean to replace the current page in the history (default is false).

let myWindow = window.open("https://www.example.com", "exampleWindow", "width=600,height=400");

2. window.close():
Purpose: Closes the current window or a window that was opened using window.open().
Syntax: window.close()
let myWindow = window.open("https://www.example.com", "exampleWindow", "width=600,height=400");
// Close the opened window after 3 seconds
setTimeout(() => {
  myWindow.close();
}, 3000);




answer 6---
To get the viewport width and height of a browser window in JavaScript, you can use the window.innerWidth and window.innerHeight properties. These give you the size of the visible area of the browser window (the area excluding things like toolbars and scrollbars)

let viewportWidth = window.innerWidth;  // Gets the width of the viewport
let viewportHeight = window.innerHeight;  // Gets the height of the viewport

console.log("Viewport Width: " + viewportWidth);
console.log("Viewport Height: " + viewportHeight);

project-
function logWindowSize() {
  let width = window.innerWidth;   // Get the viewport width
  let height = window.innerHeight; // Get the viewport height
  console.log(`Width: ${width}, Height: ${height}`);
}

// Add event listener for window resize
window.addEventListener("resize", logWindowSize);




answer 7---
1. setTimeout():
Purpose: Executes a function once after a specified delay (in milliseconds).
Syntax: setTimeout(function, delay)
function: The function to execute.
delay: The time (in milliseconds) to wait before executing the function.

setTimeout(() => {
  console.log("This message appears after 2 seconds.");
}, 2000);  // 2000 milliseconds = 2 seconds


2. setInterval():
Purpose: Executes a function repeatedly at specified intervals (in milliseconds).
Syntax: setInterval(function, interval)
function: The function to execute.
interval: The time (in milliseconds) between each function call.

setInterval(() => {
  console.log("This message appears every 3 seconds.");
}, 3000);  // 3000 milliseconds = 3 seconds


project--
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Clock</title>
  <style>
    #clock {
      font-size: 48px;
      font-family: Arial, sans-serif;
      margin-top: 20px;
    }
  </style>
</head>
<body>

  <div id="clock"></div>

  <script>
    function updateClock() {
      let now = new Date();
      let hours = now.getHours().toString().padStart(2, '0');
      let minutes = now.getMinutes().toString().padStart(2, '0');
      let seconds = now.getSeconds().toString().padStart(2, '0');
      let time = `${hours}:${minutes}:${seconds}`;
      document.getElementById("clock").textContent = time;
    }

    // Update the clock every second
    setInterval(updateClock, 1000);

    // Initial call to display the clock immediately
    updateClock();
  </script>

</body>
</html>




answer 8---
You can detect if a user is online or offline using the navigator.onLine property and the online and offline events from the Browser Object Model (BOM).

1. Using navigator.onLine:
Purpose: Returns true if the user is online (connected to the internet) and false if the user is offline.
if (navigator.onLine) {
  console.log("You are online");
} else {
  console.log("You are offline");
}


2. Using online and offline events:
These events are triggered when the user goes online or offline.
window.addEventListener("online", () => {
  console.log("You are back online!");
});

window.addEventListener("offline", () => {
  console.log("You are offline now.");
});





Web API & JSON (10 questions)....................
answer 1---
The Fetch API in JavaScript is used to make HTTP requests (like GET, POST, etc.) to fetch data from a server. It returns a Promise, which resolves to the Response object representing the response to the request.

project--
fetch("https://api.example.com/data")
  .then(response => {
    if (!response.ok) {
      throw new Error("Network response was not ok");
    }
    return response.json();  // Parse the response as JSON
  })
  .then(data => {
    console.log(data);  // Handle the data
  })
  .catch(error => {
    console.error("There was an error:", error);  // Handle errors
  });



answer 2---
XMLHttpRequest (XHR) and the Fetch API are both used for making HTTP requests in JavaScript, but they have some key differences:

Syntax: Fetch has a simpler and more modern syntax, making it easier to read and use with promises, while XHR uses more complex, callback-based code.

Promise-based: Fetch returns a promise, which is more flexible and works well with async/await. XHR doesn’t support promises natively, so it requires callbacks.

Streaming: Fetch supports streaming responses, allowing you to start working with data as it downloads, whereas XHR waits until the response is fully loaded.

Error Handling: Fetch has more predictable error handling. XHR requires more setup to catch errors correctly.

Cross-origin Requests: Fetch has improved support for CORS (Cross-Origin Resource Sharing), making it easier to handle requests across domains.

In short: Fetch is generally preferred for modern JavaScript because it's simpler, more powerful, and easier to use with asynchronous code.



answer 3---
JSON (JavaScript Object Notation) is a lightweight data format used to store and exchange data. It's written as key-value pairs, similar to JavaScript objects, making it easy for humans to read and write.

In JavaScript, JSON is often used to send data between a server and a client. You can turn a JavaScript object into JSON using JSON.stringify() and parse JSON back into a JavaScript object with JSON.parse().

// JavaScript object
const person = { name: "Alice", age: 25 };

// Convert to JSON
const jsonString = JSON.stringify(person);

// Convert back to JavaScript object
const jsonObject = JSON.parse(jsonString);




answer 4---
project..
function convertToJSONAndBack(obj) {
  // Convert the object to a JSON string
  const jsonString = JSON.stringify(obj);
  console.log("JSON String:", jsonString); // Display the JSON string for reference

  // Convert the JSON string back to an object
  const jsonObject = JSON.parse(jsonString);
  console.log("Back to Object:", jsonObject); // Display the object for reference

  return jsonObject;
}

// Example usage:
const originalObject = { name: "Alice", age: 25, city: "Wonderland" };
const resultObject = convertToJSONAndBack(originalObject);




answer 5---
CORS (Cross-Origin Resource Sharing) is a security feature that controls how web pages can request data from a different domain than the one they’re on. By default, browsers block requests from one domain to another for security reasons.

CORS allows a server to specify who can access its resources and what methods (like GET, POST) are allowed. When you make an API request to a different domain, CORS headers on the server let the browser know if it’s safe to share the response with your site.

Without proper CORS settings, API requests from a different domain will be blocked, which is why we need CORS to enable safe, cross-domain data sharing.



answer 7---
The FormData API is used to easily collect and send form data (like text inputs, files, etc.) as part of an HTTP request, typically via AJAX.

How it works:
Create a FormData object: You can create a FormData object by passing a form element to it, or manually adding form fields.
Send data: You can send this data with an AJAX request, usually through fetch() or XMLHttpRequest.

// Create FormData from a form element
const form = document.querySelector('form');
const formData = new FormData(form);

// Send the form data using fetch
fetch('submitForm', {
  method: 'POST',
  body: formData,
});

When to use:
Sending form data without reloading the page: It's useful for submitting forms via AJAX.
Uploading files: FormData handles file uploads automatically.



answer 7---
The History API allows you to manipulate the browser's history without reloading the page. This is useful for single-page applications (SPAs) where you want to change the URL or state of the page without a full page refresh.

1.pushState(): Adds a new entry to the browser's history. It changes the URL and allows you to save state information for the page.
history.pushState({ page: 1 }, "Page 1", "/page1");

2.replaceState(): Modifies the current history entry instead of adding a new one. It’s useful for updating the state or URL without creating a new entry in the history.
history.replaceState({ page: 2 }, "Page 2", "/page2");

Purpose:
Enhance user experience: Allows navigation changes (like updating URLs) without reloading the page, improving performance and user flow.
Better control over navigation: Enables the back and forward buttons to work with your app’s custom navigation.


project-
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Simple Navigation</title>
</head>
<body>
  <nav>
    <button onclick="navigateTo('home')">Home</button>
    <button onclick="navigateTo('about')">About</button>
    <button onclick="navigateTo('contact')">Contact</button>
  </nav>

  <div id="content"></div>

  <script src="app.js"></script>
</body>
</html>

function navigateTo(page) {
  // Update the URL without reloading the page
  history.pushState({ page: page }, `${page} page`, `/${page}`);
  
  // Show content based on the page
  loadPageContent(page);
}

// Function to load content based on the current page
function loadPageContent(page) {
  const content = document.getElementById("content");

  if (page === 'home') {
    content.innerHTML = "<h1>Home Page</h1><p>Welcome to the home page.</p>";
  } else if (page === 'about') {
    content.innerHTML = "<h1>About Page</h1><p>Learn more about us here.</p>";
  } else if (page === 'contact') {
    content.innerHTML = "<h1>Contact Page</h1><p>Get in touch with us here.</p>";
  }
}

// Handle back/forward navigation
window.onpopstate = function(event) {
  if (event.state) {
    loadPageContent(event.state.page);
  }
};

// Initialize with the home page
navigateTo('home');




answer 8---
1. Using try/catch with async/await:
async function fetchData() {
  try {
    const response = await fetch("https://api.example.com/data");
    if (!response.ok) {
      throw new Error("Network response was not ok");
    }
    const data = await response.json();
    console.log(data);
  } catch (error) {
    console.error("Fetch error:", error);
  }
}
fetchData();


2. Using .catch() with Promises:
fetch("https://api.example.com/data")
  .then(response => {
    if (!response.ok) {
      throw new Error("Network response was not ok");
    }
    return response.json();
  })
  .then(data => console.log(data))
  .catch(error => console.error("Fetch error:", error));


answer 9---

WebSockets are a protocol that enables a continuous, two-way connection between a client and server. Unlike HTTP requests, which are one-way and require a client to initiate each request to get data, WebSockets allow both the client and server to send data to each other anytime after the connection is established.

Key Differences:
Persistent Connection: WebSockets keep a continuous connection open, whereas HTTP is stateless and closes after each request.
Real-Time Communication: WebSockets are ideal for real-time applications (e.g., chat apps, live data feeds), allowing immediate updates without the client repeatedly requesting new data, unlike HTTP.
Two-Way: WebSockets support full-duplex (two-way) communication, while HTTP is typically one-way, with the client requesting and the server responding.



answer 10---

The Service Worker API is a web technology that enables background scripts to intercept network requests, cache assets, and manage offline behavior for web applications. It’s a key component for creating Progressive Web Apps (PWAs), which are web apps that work offline and feel like native apps.

Basics:
Installation: Service workers are registered in the browser and "installed" to control a web app.
Caching: They can cache assets (like HTML, CSS, and images) during installation, allowing users to access the app offline.
Interception of Requests: Service workers intercept network requests and serve cached assets when the network is unavailable, improving speed and reliability.
Lifecycle: Service workers have a lifecycle independent of the web page, meaning they continue running even if the page is closed.

Use in PWAs:
Offline Support: Service workers enable PWAs to work offline by serving cached content when there’s no network connection.
Faster Load Times: Cached resources allow pages to load faster, even on slow connections.
Push Notifications: Service workers handle push notifications, enhancing user engagement.
Background Sync: They enable syncing of data in the background when a connection is re-established.
In summary, service workers make PWAs more resilient, reliable, and user-friendly by providing offline functionality, faster loading, and native app-like features.
















































